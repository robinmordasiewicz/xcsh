//go:build ignore

// generate-examples.go generates examples_generated.go from OpenAPI specifications.
// Run with: go run scripts/generate-examples.go
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"text/template"

	"github.com/robinmordasiewicz/f5xcctl/pkg/openapi"
	"github.com/robinmordasiewicz/f5xcctl/pkg/types"
)

var (
	outputFile = flag.String("output", "pkg/types/examples_generated.go", "Output file path")
	specsDir   = flag.String("specs", "docs/specifications/api", "Directory containing OpenAPI specs")
	verbose    = flag.Bool("v", false, "Verbose output")
)

const fileTemplate = `// Code generated by generate-examples.go. DO NOT EDIT.
// This file contains JSON examples for CLI help output.

package types

// resourceExamples maps resource names to their JSON example bodies.
// These examples are generated from OpenAPI specifications.
var resourceExamples = map[string]string{
{{- range $name, $example := .Examples }}
	"{{ $name }}": ` + "`" + `{{ $example }}` + "`" + `,
{{- end }}
}

// GetResourceExample returns the JSON example for a resource type.
// Returns empty string if no example is available.
func GetResourceExample(resourceName string) string {
	return resourceExamples[resourceName]
}
`

func main() {
	flag.Parse()

	if *verbose {
		fmt.Println("Loading OpenAPI specifications...")
	}

	// Load all specs with transformation to normalize legacy references
	specs, err := openapi.LoadAllSpecsWithTransform(*specsDir, openapi.DefaultTransformConfig())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading specs: %v\n", err)
		os.Exit(1)
	}

	if *verbose {
		fmt.Printf("Loaded %d OpenAPI specifications\n", len(specs))
	}

	// Create spec mapper
	mapper := openapi.NewSpecMapper(specs)

	// Get all registered resource types
	allResources := types.All()
	if *verbose {
		fmt.Printf("Found %d registered resource types\n", len(allResources))
	}

	// Generate examples for each resource
	examples := make(map[string]string)
	generated := 0
	skipped := 0

	for _, rt := range allResources {
		// Only generate examples for resources that support create
		if !rt.Operations.Create {
			continue
		}

		example, err := mapper.GenerateExampleForResource(rt.Name)
		if err != nil {
			if *verbose {
				fmt.Fprintf(os.Stderr, "Warning: error generating example for %s: %v\n", rt.Name, err)
			}
			skipped++
			continue
		}

		if example == "" {
			if *verbose {
				fmt.Printf("  Skipped %s (no spec found)\n", rt.Name)
			}
			skipped++
			continue
		}

		// Escape backticks in the example for Go raw string literals
		example = escapeForGoRawString(example)

		examples[rt.Name] = example
		generated++

		if *verbose {
			fmt.Printf("  Generated example for %s\n", rt.Name)
		}
	}

	if *verbose {
		fmt.Printf("\nGenerated %d examples, skipped %d\n", generated, skipped)
	}

	// Generate the output file
	if err := writeGeneratedFile(*outputFile, examples); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d resource examples\n", *outputFile, generated)
}

// escapeForGoRawString escapes content for use in Go raw string literals
func escapeForGoRawString(s string) string {
	// In raw strings, we can't have backticks
	// Replace any backticks with ' + "`" + '
	// But since we're generating the file, we'll avoid backticks in examples
	// For now, just return as-is since JSON shouldn't have backticks
	return s
}

// writeGeneratedFile writes the generated Go file
func writeGeneratedFile(outputPath string, examples map[string]string) error {
	// Ensure output directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Sort examples by key for deterministic output
	sortedExamples := make(map[string]string)
	var keys []string
	for k := range examples {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		sortedExamples[k] = examples[k]
	}

	// Create output file
	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	// Parse and execute template
	tmpl, err := template.New("generated").Parse(fileTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	// Custom template function to iterate in sorted order
	data := struct {
		Examples map[string]string
	}{
		Examples: sortedExamples,
	}

	// We need to write with sorted keys
	// Since Go maps don't preserve order in range, we'll write manually
	header := `// Code generated by generate-examples.go. DO NOT EDIT.
// This file contains JSON examples for CLI help output.

package types

// resourceExamples maps resource names to their JSON example bodies.
// These examples are generated from OpenAPI specifications.
var resourceExamples = map[string]string{
`
	footer := `}

// GetResourceExample returns the JSON example for a resource type.
// Returns empty string if no example is available.
func GetResourceExample(resourceName string) string {
	return resourceExamples[resourceName]
}
`

	if _, err := f.WriteString(header); err != nil {
		return err
	}

	for _, key := range keys {
		example := examples[key]
		// Write each entry
		line := fmt.Sprintf("\t%q: `%s`,\n", key, example)
		if _, err := f.WriteString(line); err != nil {
			return err
		}
	}

	if _, err := f.WriteString(footer); err != nil {
		return err
	}

	_ = tmpl // Silence unused warning
	_ = data

	return nil
}

// init ensures the package can be built
func init() {
	// Verify types package is imported correctly
	_ = types.All
}
