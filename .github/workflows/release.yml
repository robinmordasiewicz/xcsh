name: Release

on:
  push:
    branches:
      - main

# Cancel in-progress runs when a new run is triggered
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for code changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            code:
              - '**.ts'
              - '**.tsx'
              - 'package.json'
              - 'package-lock.json'

      - name: Set up Node.js
        if: steps.changes.outputs.code == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        if: steps.changes.outputs.code == 'true'
        run: npm ci

      - name: Run tests
        if: steps.changes.outputs.code == 'true'
        run: npm test

      - name: Run type check
        if: steps.changes.outputs.code == 'true'
        run: npm run typecheck

  version:
    name: Bump Version
    runs-on: ubuntu-latest
    needs: test
    outputs:
      version: ${{ steps.bump.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag and bump version
        id: bump
        run: |
          # Get latest tag, default to v0.0.0 if none
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Extract version numbers from tag
          TAG_VERSION=${LATEST_TAG#v}
          TAG_MAJOR=$(echo $TAG_VERSION | cut -d. -f1)
          TAG_MINOR=$(echo $TAG_VERSION | cut -d. -f2)

          # Read major version from package.json (source of truth for major versions)
          PKG_VERSION=$(node -p "require('./package.json').version")
          PKG_MAJOR=$(echo $PKG_VERSION | cut -d. -f1)
          echo "Package.json version: $PKG_VERSION (major: $PKG_MAJOR)"

          # If package.json major version is higher, use it (major version bump)
          if [ "$PKG_MAJOR" -gt "$TAG_MAJOR" ]; then
            echo "Major version bump detected from package.json"
            NEW_VERSION="${PKG_MAJOR}.0.0"
          else
            # Normal minor version increment
            NEW_MINOR=$((TAG_MINOR + 1))
            NEW_VERSION="${TAG_MAJOR}.${NEW_MINOR}.0"
          fi

          echo "New version: v$NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "v${{ steps.bump.outputs.version }}" -m "Release v${{ steps.bump.outputs.version }}"
          git push origin "v${{ steps.bump.outputs.version }}"

  # Build binaries on native platforms to avoid cross-compilation issues
  # Bun cross-compilation does not work reliably (especially for macOS)
  build-linux:
    name: Build Linux Binaries
    runs-on: ubuntu-latest
    needs: version
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download enriched API specifications
        run: ./scripts/download-specs.sh

      - name: Build TypeScript
        run: XCSH_VERSION=${{ needs.version.outputs.version }} npm run build

      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Build Linux binaries
        run: ./scripts/build-binaries.sh --platform linux

      - name: Upload Linux binaries
        uses: actions/upload-artifact@v4
        with:
          name: binaries-linux
          path: binaries/
          retention-days: 1

  build-macos:
    name: Build macOS Binaries
    runs-on: macos-latest
    needs: version
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download enriched API specifications
        run: ./scripts/download-specs.sh

      - name: Build TypeScript
        run: XCSH_VERSION=${{ needs.version.outputs.version }} npm run build

      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Build macOS binaries
        run: ./scripts/build-binaries.sh --platform darwin

      - name: Upload macOS binaries
        uses: actions/upload-artifact@v4
        with:
          name: binaries-macos
          path: binaries/
          retention-days: 1

  build-windows:
    name: Build Windows Binaries
    runs-on: windows-latest
    needs: version
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download enriched API specifications
        shell: bash
        run: ./scripts/download-specs.sh

      - name: Build TypeScript
        run: npm run build
        env:
          XCSH_VERSION: ${{ needs.version.outputs.version }}

      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Build Windows binaries
        shell: bash
        run: ./scripts/build-binaries.sh --platform windows

      - name: Upload Windows binaries
        uses: actions/upload-artifact@v4
        with:
          name: binaries-windows
          path: binaries/
          retention-days: 1

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [version, build-linux, build-macos, build-windows]
    outputs:
      version: ${{ needs.version.outputs.version }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: binaries
          merge-multiple: true

      - name: List downloaded binaries
        run: ls -la binaries/

      - name: Create release archives
        run: |
          VERSION="${{ needs.version.outputs.version }}"
          mkdir -p release-archives

          # Create archives for each platform
          for file in binaries/*; do
            filename=$(basename "$file")

            case "$filename" in
              *-linux-x64)
                ARCHIVE_NAME="xcsh_${VERSION}_linux_amd64.tar.gz"
                mv "$file" xcsh
                chmod +x xcsh
                tar -czf "release-archives/${ARCHIVE_NAME}" xcsh
                rm xcsh
                ;;
              *-linux-arm64)
                ARCHIVE_NAME="xcsh_${VERSION}_linux_arm64.tar.gz"
                mv "$file" xcsh
                chmod +x xcsh
                tar -czf "release-archives/${ARCHIVE_NAME}" xcsh
                rm xcsh
                ;;
              *-macos-x64)
                ARCHIVE_NAME="xcsh_${VERSION}_darwin_amd64.tar.gz"
                mv "$file" xcsh
                chmod +x xcsh
                tar -czf "release-archives/${ARCHIVE_NAME}" xcsh
                rm xcsh
                ;;
              *-macos-arm64)
                ARCHIVE_NAME="xcsh_${VERSION}_darwin_arm64.tar.gz"
                mv "$file" xcsh
                chmod +x xcsh
                tar -czf "release-archives/${ARCHIVE_NAME}" xcsh
                rm xcsh
                ;;
              *-win-x64.exe)
                ARCHIVE_NAME="xcsh_${VERSION}_windows_amd64.zip"
                mv "$file" xcsh.exe
                zip "release-archives/${ARCHIVE_NAME}" xcsh.exe
                rm xcsh.exe
                ;;
              *-win-arm64.exe)
                ARCHIVE_NAME="xcsh_${VERSION}_windows_arm64.zip"
                mv "$file" xcsh.exe
                zip "release-archives/${ARCHIVE_NAME}" xcsh.exe
                rm xcsh.exe
                ;;
            esac
          done

          ls -la release-archives/

      - name: Generate checksums
        run: |
          cd release-archives
          shasum -a 256 * > checksums.txt
          cat checksums.txt

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.version.outputs.version }}"

          # Create release notes
          cat > release-notes.md << 'RELEASE_EOF'
          ## xcsh v${VERSION}

          ### Installation

          **macOS (Apple Silicon)**
          ```bash
          curl -LO https://github.com/robinmordasiewicz/xcsh/releases/download/v${VERSION}/xcsh_${VERSION}_darwin_arm64.tar.gz
          tar -xzf xcsh_${VERSION}_darwin_arm64.tar.gz
          sudo mv xcsh /usr/local/bin/
          ```

          **macOS (Intel)**
          ```bash
          curl -LO https://github.com/robinmordasiewicz/xcsh/releases/download/v${VERSION}/xcsh_${VERSION}_darwin_amd64.tar.gz
          tar -xzf xcsh_${VERSION}_darwin_amd64.tar.gz
          sudo mv xcsh /usr/local/bin/
          ```

          **Linux (amd64)**
          ```bash
          curl -LO https://github.com/robinmordasiewicz/xcsh/releases/download/v${VERSION}/xcsh_${VERSION}_linux_amd64.tar.gz
          tar -xzf xcsh_${VERSION}_linux_amd64.tar.gz
          sudo mv xcsh /usr/local/bin/
          ```

          **Linux (arm64)**
          ```bash
          curl -LO https://github.com/robinmordasiewicz/xcsh/releases/download/v${VERSION}/xcsh_${VERSION}_linux_arm64.tar.gz
          tar -xzf xcsh_${VERSION}_linux_arm64.tar.gz
          sudo mv xcsh /usr/local/bin/
          ```

          **Windows (amd64)**
          Download `xcsh_${VERSION}_windows_amd64.zip` and extract to your PATH.

          **npm (requires Node.js)**
          ```bash
          npm install -g xcsh
          ```
          RELEASE_EOF

          # Substitute version in release notes
          sed -i "s/\${VERSION}/${VERSION}/g" release-notes.md

          # Create GitHub release
          gh release create "v${VERSION}" \
            --title "xcsh v${VERSION}" \
            --notes-file release-notes.md \
            release-archives/*

  sign-macos:
    name: Sign macOS Binaries
    runs-on: macos-latest
    needs: create-release
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Import Code Signing Certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Store for later steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          # Decode certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          echo "Certificate decoded, checking..."

          # Verify p12 is valid
          openssl pkcs12 -info -in $RUNNER_TEMP/certificate.p12 -noout -passin pass:"$APPLE_CERTIFICATE_PASSWORD" || {
            echo "ERROR: Invalid p12 file or wrong password"
            exit 1
          }

          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security default-keychain -s $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate with proper options
          echo "Importing certificate..."
          security import $RUNNER_TEMP/certificate.p12 \
            -k $KEYCHAIN_PATH \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security

          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Add to search list
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Verify import worked
          echo "Verifying certificate import..."
          security find-identity -v -p codesigning $KEYCHAIN_PATH

          # Clean up certificate file
          rm $RUNNER_TEMP/certificate.p12

      - name: Download and Sign macOS Binaries
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Signing version: $VERSION"

          # Retry function with exponential backoff
          retry_with_backoff() {
            local max_attempts=5
            local base_delay=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if "$@"; then
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                delay=$((base_delay * (2 ** (attempt - 1))))
                echo "::warning::Attempt $attempt failed, retrying in ${delay}s..."
                sleep $delay
              fi
              attempt=$((attempt + 1))
            done

            echo "::error::All $max_attempts attempts failed"
            return 1
          }

          # Unlock keychain for this step
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Find the Developer ID Application certificate from our keychain
          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          SIGNING_IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          if [ -z "$SIGNING_IDENTITY" ]; then
            echo "ERROR: No Developer ID signing identity found"
            exit 1
          fi
          echo "Using signing identity: $SIGNING_IDENTITY"

          # Process each macOS architecture
          for ARCH in amd64 arm64; do
            ASSET_NAME="xcsh_${VERSION}_darwin_${ARCH}.tar.gz"
            echo "Processing $ASSET_NAME..."

            # Download release asset with retry
            retry_with_backoff gh release download "v${VERSION}" -p "$ASSET_NAME" -D $RUNNER_TEMP

            # Extract
            mkdir -p $RUNNER_TEMP/sign_${ARCH}
            tar -xzf $RUNNER_TEMP/$ASSET_NAME -C $RUNNER_TEMP/sign_${ARCH}

            # Sign the binary
            BINARY_PATH="$RUNNER_TEMP/sign_${ARCH}/xcsh"
            echo "Signing $BINARY_PATH..."

            codesign --force --options runtime --sign "$SIGNING_IDENTITY" --timestamp "$BINARY_PATH"

            # Verify signature
            codesign --verify --verbose "$BINARY_PATH"

            # Create ZIP for notarization
            ZIP_PATH="$RUNNER_TEMP/xcsh_${ARCH}.zip"
            ditto -c -k --keepParent "$BINARY_PATH" "$ZIP_PATH"

            # Submit for notarization and wait for completion
            echo "Submitting for notarization..."
            xcrun notarytool submit "$ZIP_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait

            echo "Notarization complete for $ARCH (stapling skipped - not supported for bare binaries)"

            # Verify the signed binary with spctl
            echo "Verifying signed binary with spctl..."
            spctl -a -vvv -t execute "$BINARY_PATH" || {
              echo "WARNING: spctl verification may fail in CI (no GUI), continuing..."
            }
            echo "Binary ready for $ARCH"

            # Repackage as tar.gz
            cd $RUNNER_TEMP/sign_${ARCH}
            tar -czf $RUNNER_TEMP/${ASSET_NAME} *
            cd -

            # Upload signed binary to release (replace unsigned)
            echo "Uploading signed $ASSET_NAME..."
            gh release upload "v${VERSION}" $RUNNER_TEMP/$ASSET_NAME --clobber
          done

          echo "macOS binaries signed and uploaded successfully!"

      - name: Regenerate checksums.txt with signed binary hashes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Regenerating checksums.txt for version $VERSION..."

          # Retry function with exponential backoff
          retry_with_backoff() {
            local max_attempts=5
            local base_delay=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if "$@"; then
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                delay=$((base_delay * (2 ** (attempt - 1))))
                echo "::warning::Attempt $attempt failed, retrying in ${delay}s..."
                sleep $delay
              fi
              attempt=$((attempt + 1))
            done

            echo "::error::All $max_attempts attempts failed"
            return 1
          }

          # Create working directory
          mkdir -p $RUNNER_TEMP/checksums
          cd $RUNNER_TEMP/checksums

          # Download all release assets with retry
          echo "Downloading all release assets..."
          retry_with_backoff sh -c "GH_TOKEN=\"\$GITHUB_TOKEN\" gh release download \"v${VERSION}\" --repo \"${{ github.repository }}\""

          # Generate new checksums.txt
          echo "Computing SHA256 checksums..."
          shasum -a 256 xcsh_${VERSION}_*.tar.gz xcsh_${VERSION}_*.zip 2>/dev/null | tee checksums.txt

          # Upload new checksums.txt to replace the old one
          echo "Uploading updated checksums.txt..."
          GH_TOKEN="$GITHUB_TOKEN" gh release upload "v${VERSION}" checksums.txt --clobber --repo "${{ github.repository }}"

          echo "checksums.txt regenerated successfully!"

      - name: Update Homebrew cask with signed binary hashes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"

          echo "Computing SHA256 hashes for all release assets..."

          # Retry function with exponential backoff
          retry_with_backoff() {
            local max_attempts=5
            local base_delay=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if "$@"; then
                return 0
              fi

              if [ $attempt -lt $max_attempts ]; then
                delay=$((base_delay * (2 ** (attempt - 1))))
                echo "::warning::Attempt $attempt failed, retrying in ${delay}s..."
                sleep $delay
              fi
              attempt=$((attempt + 1))
            done

            echo "::error::All $max_attempts attempts failed"
            return 1
          }

          # Download all release tarballs and compute hashes
          mkdir -p $RUNNER_TEMP/hash_check
          cd $RUNNER_TEMP/hash_check

          # Download and compute hash for each platform
          for PLATFORM in darwin_amd64 darwin_arm64 linux_amd64 linux_arm64; do
            ASSET="xcsh_${VERSION}_${PLATFORM}.tar.gz"
            echo "Downloading $ASSET..."
            retry_with_backoff sh -c "GH_TOKEN=\"\$GITHUB_TOKEN\" gh release download \"v${VERSION}\" --pattern \"$ASSET\" --repo \"${{ github.repository }}\""
            HASH=$(shasum -a 256 "$ASSET" | cut -d' ' -f1)
            export "HASH_${PLATFORM}=${HASH}"
            echo "$PLATFORM: $HASH"
          done

          # Clone homebrew-tap and update cask
          cd $RUNNER_TEMP
          git clone https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/robinmordasiewicz/homebrew-tap.git
          cd homebrew-tap

          # Update the cask file with correct hashes
          cat > Casks/xcsh.rb << CASKEOF
          cask "xcsh" do
            name "xcsh"
            desc "Command-line interface for F5 Distributed Cloud"
            homepage "https://robinmordasiewicz.github.io/xcsh"
            version "${VERSION}"

            livecheck do
              skip "Auto-generated on release."
            end

            binary "xcsh"

            on_macos do
              on_intel do
                url "https://github.com/robinmordasiewicz/xcsh/releases/download/v#{version}/xcsh_#{version}_darwin_amd64.tar.gz"
                sha256 "${HASH_darwin_amd64}"
              end
              on_arm do
                url "https://github.com/robinmordasiewicz/xcsh/releases/download/v#{version}/xcsh_#{version}_darwin_arm64.tar.gz"
                sha256 "${HASH_darwin_arm64}"
              end
            end

            on_linux do
              on_intel do
                url "https://github.com/robinmordasiewicz/xcsh/releases/download/v#{version}/xcsh_#{version}_linux_amd64.tar.gz"
                sha256 "${HASH_linux_amd64}"
              end
              on_arm do
                url "https://github.com/robinmordasiewicz/xcsh/releases/download/v#{version}/xcsh_#{version}_linux_arm64.tar.gz"
                sha256 "${HASH_linux_arm64}"
              end
            end

            caveats <<~EOS
              xcsh has been installed.

              For setup instructions, see:
                https://robinmordasiewicz.github.io/xcsh/install/homebrew/

              Quick start:
                xcsh --help
            EOS
          end
          CASKEOF

          # Remove leading whitespace from heredoc
          sed -i '' 's/^          //' Casks/xcsh.rb

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Casks/xcsh.rb
          git commit -m "chore: Update xcsh cask to v${VERSION}"
          git push
