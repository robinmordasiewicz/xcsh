name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for code changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            code:
              - '**.go'
              - 'go.mod'
              - 'go.sum'

      - name: Set up Go
        if: steps.changes.outputs.code == 'true'
        uses: actions/setup-go@v6
        with:
          go-version: "1.24"
          cache: true

      - name: Run tests
        if: steps.changes.outputs.code == 'true'
        run: go test -v -race ./pkg/...

  docs-check:
    name: Documentation Check
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for code changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            code:
              - '**.go'
              - 'go.mod'
              - 'go.sum'

      - name: Set up Go
        if: steps.changes.outputs.code == 'true'
        uses: actions/setup-go@v6
        with:
          go-version: "1.24"
          cache: true

      - name: Set up Python
        if: steps.changes.outputs.code == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install mkdocs
        if: steps.changes.outputs.code == 'true'
        run: pip install mkdocs mkdocs-material

      - name: Generate docs
        if: steps.changes.outputs.code == 'true'
        run: make docs

      - name: Check for uncommitted changes
        if: steps.changes.outputs.code == 'true'
        run: |
          if [ -n "$(git status --porcelain docs/)" ]; then
            echo "::error::Documentation is out of date. Run 'make docs' and commit the changes."
            git diff docs/
            exit 1
          fi

  semantic-release:
    name: Semantic Release
    runs-on: ubuntu-latest
    needs: [test, docs-check]
    outputs:
      version: ${{ steps.semantic.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Run go-semantic-release
        id: semantic
        uses: go-semantic-release/action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  goreleaser:
    name: GoReleaser
    runs-on: ubuntu-latest
    needs: semantic-release
    if: needs.semantic-release.outputs.version != ''
    outputs:
      version: ${{ needs.semantic-release.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: "1.24"
          cache: false

      - name: Install GoReleaser with retry
        shell: bash
        run: |
          GORELEASER_VERSION="2.13.1"
          max_retries=5
          base_delay=15

          for attempt in $(seq 1 $max_retries); do
            echo "Attempt $attempt of $max_retries to install GoReleaser v${GORELEASER_VERSION}..."

            # Download goreleaser tarball from GitHub releases
            url="https://github.com/goreleaser/goreleaser/releases/download/v${GORELEASER_VERSION}/goreleaser_Linux_x86_64.tar.gz"
            if curl -sSL --connect-timeout 30 --max-time 180 -o /tmp/goreleaser.tar.gz "$url" && \
               tar -xzf /tmp/goreleaser.tar.gz -C /tmp goreleaser && \
               sudo mv /tmp/goreleaser /usr/local/bin/goreleaser && \
               chmod +x /usr/local/bin/goreleaser; then
              echo "GoReleaser installed successfully"
              goreleaser --version
              rm -f /tmp/goreleaser.tar.gz
              exit 0
            fi

            if [ $attempt -lt $max_retries ]; then
              delay=$((base_delay * attempt))
              echo "::warning::Failed to install GoReleaser on attempt $attempt, retrying in ${delay}s..."
              rm -f /tmp/goreleaser.tar.gz /tmp/goreleaser
              sleep $delay
            fi
          done

          echo "::error::Failed to install GoReleaser after $max_retries attempts"
          exit 1

      - name: Run GoReleaser
        shell: bash
        run: goreleaser release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HOMEBREW_TAP_GITHUB_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}

  sign-macos:
    name: Sign macOS Binaries
    runs-on: macos-latest
    needs: goreleaser
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Import Code Signing Certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Store for later steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          # Decode certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          echo "Certificate decoded, checking..."

          # Verify p12 is valid
          openssl pkcs12 -info -in $RUNNER_TEMP/certificate.p12 -noout -passin pass:"$APPLE_CERTIFICATE_PASSWORD" || {
            echo "ERROR: Invalid p12 file or wrong password"
            exit 1
          }

          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security default-keychain -s $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate with proper options
          echo "Importing certificate..."
          security import $RUNNER_TEMP/certificate.p12 \
            -k $KEYCHAIN_PATH \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security

          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Add to search list
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Verify import worked
          echo "Verifying certificate import..."
          security find-identity -v -p codesigning $KEYCHAIN_PATH

          # Clean up certificate file
          rm $RUNNER_TEMP/certificate.p12

      - name: Download and Sign macOS Binaries
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ needs.goreleaser.outputs.version }}"
          echo "Signing version: $VERSION"

          # Unlock keychain for this step
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Find the Developer ID Application certificate from our keychain
          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          SIGNING_IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          if [ -z "$SIGNING_IDENTITY" ]; then
            echo "ERROR: No Developer ID signing identity found"
            exit 1
          fi
          echo "Using signing identity: $SIGNING_IDENTITY"

          # Process each macOS architecture
          for ARCH in amd64 arm64; do
            ASSET_NAME="vesctl_${VERSION}_darwin_${ARCH}.tar.gz"
            echo "Processing $ASSET_NAME..."

            # Download release asset
            gh release download "v${VERSION}" -p "$ASSET_NAME" -D $RUNNER_TEMP

            # Extract
            mkdir -p $RUNNER_TEMP/sign_${ARCH}
            tar -xzf $RUNNER_TEMP/$ASSET_NAME -C $RUNNER_TEMP/sign_${ARCH}

            # Sign the binary
            BINARY_PATH="$RUNNER_TEMP/sign_${ARCH}/vesctl"
            echo "Signing $BINARY_PATH..."

            codesign --force --options runtime --sign "$SIGNING_IDENTITY" --timestamp "$BINARY_PATH"

            # Verify signature
            codesign --verify --verbose "$BINARY_PATH"

            # Create ZIP for notarization
            ZIP_PATH="$RUNNER_TEMP/vesctl_${ARCH}.zip"
            ditto -c -k --keepParent "$BINARY_PATH" "$ZIP_PATH"

            # Submit for notarization
            echo "Submitting for notarization..."
            xcrun notarytool submit "$ZIP_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait

            # Repackage as tar.gz (preserving all original files including completions)
            cd $RUNNER_TEMP/sign_${ARCH}
            # Use * to get all files without ./ prefix, preserving original archive structure
            tar -czf $RUNNER_TEMP/${ASSET_NAME} *
            cd -

            # Upload signed binary to release (replace unsigned)
            echo "Uploading signed $ASSET_NAME..."
            gh release upload "v${VERSION}" $RUNNER_TEMP/$ASSET_NAME --clobber
          done

          echo "macOS binaries signed and uploaded successfully!"

      - name: Regenerate checksums.txt with signed binary hashes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.goreleaser.outputs.version }}"
          echo "Regenerating checksums.txt for version $VERSION..."

          # Create working directory
          mkdir -p $RUNNER_TEMP/checksums
          cd $RUNNER_TEMP/checksums

          # Download all release assets
          echo "Downloading all release assets..."
          GH_TOKEN="$GITHUB_TOKEN" gh release download "v${VERSION}" --repo "${{ github.repository }}"

          # Generate new checksums.txt
          echo "Computing SHA256 checksums..."
          shasum -a 256 vesctl_${VERSION}_*.tar.gz vesctl_${VERSION}_*.zip 2>/dev/null | tee checksums.txt

          # Upload new checksums.txt to replace the old one
          echo "Uploading updated checksums.txt..."
          GH_TOKEN="$GITHUB_TOKEN" gh release upload "v${VERSION}" checksums.txt --clobber --repo "${{ github.repository }}"

          echo "checksums.txt regenerated successfully!"

      - name: Update Homebrew cask with signed binary hashes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          VERSION="${{ needs.goreleaser.outputs.version }}"

          echo "Computing SHA256 hashes for all release assets..."

          # Download all release tarballs and compute hashes
          mkdir -p $RUNNER_TEMP/hash_check
          cd $RUNNER_TEMP/hash_check

          # Download and compute hash for each platform (using GITHUB_TOKEN for vesctl repo)
          for PLATFORM in darwin_amd64 darwin_arm64 linux_amd64 linux_arm64; do
            ASSET="vesctl_${VERSION}_${PLATFORM}.tar.gz"
            echo "Downloading $ASSET..."
            GH_TOKEN="$GITHUB_TOKEN" gh release download "v${VERSION}" --pattern "$ASSET" --repo "${{ github.repository }}"
            HASH=$(shasum -a 256 "$ASSET" | cut -d' ' -f1)
            # Export hash as environment variable for later use
            export "HASH_${PLATFORM}=${HASH}"
            echo "$PLATFORM: $HASH"
          done

          # Clone homebrew-tap and update cask (using HOMEBREW_TAP_TOKEN for push access)
          cd $RUNNER_TEMP
          git clone https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/robinmordasiewicz/homebrew-tap.git
          cd homebrew-tap

          # Update the cask file with correct hashes
          cat > Casks/vesctl.rb << CASKEOF
          # This file was generated by GoReleaser. DO NOT EDIT.
          cask "vesctl" do
            name "vesctl"
            desc "Command-line interface for F5 Distributed Cloud"
            homepage "https://robinmordasiewicz.github.io/vesctl"
            version "${VERSION}"

            livecheck do
              skip "Auto-generated on release."
            end

            binary "vesctl"
            bash_completion "completions/vesctl.bash"
            zsh_completion "completions/vesctl.zsh"
            fish_completion "completions/vesctl.fish"

            on_macos do
              on_intel do
                url "https://github.com/robinmordasiewicz/vesctl/releases/download/v#{version}/vesctl_#{version}_darwin_amd64.tar.gz"
                sha256 "${HASH_darwin_amd64}"
              end
              on_arm do
                url "https://github.com/robinmordasiewicz/vesctl/releases/download/v#{version}/vesctl_#{version}_darwin_arm64.tar.gz"
                sha256 "${HASH_darwin_arm64}"
              end
            end

            on_linux do
              on_intel do
                url "https://github.com/robinmordasiewicz/vesctl/releases/download/v#{version}/vesctl_#{version}_linux_amd64.tar.gz"
                sha256 "${HASH_linux_amd64}"
              end
              on_arm do
                url "https://github.com/robinmordasiewicz/vesctl/releases/download/v#{version}/vesctl_#{version}_linux_arm64.tar.gz"
                sha256 "${HASH_linux_arm64}"
              end
            end

            caveats <<~EOS
              Shell completions have been installed for bash, zsh, and fish.

              For setup instructions, see:
                https://robinmordasiewicz.github.io/vesctl/install/homebrew/#shell-completions

              Quick start:
                Zsh: Usually works automatically. Restart your terminal.
                Bash: Run 'brew install bash-completion@2' first.
                Fish: Works automatically.

              Test with: vesctl [TAB]
            EOS
          end
          CASKEOF

          # Remove leading whitespace from heredoc
          sed -i '' 's/^          //' Casks/vesctl.rb

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Casks/vesctl.rb
          git commit -m "fix: update SHA256 hashes for signed macOS binaries v${VERSION}"
          git push
