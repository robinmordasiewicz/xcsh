name: Release

on:
  push:
    branches:
      - main

# Cancel in-progress runs when a new run is triggered
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for code changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            code:
              - '**.go'
              - 'go.mod'
              - 'go.sum'

      - name: Set up Go
        if: steps.changes.outputs.code == 'true'
        uses: actions/setup-go@v6
        with:
          go-version: "1.25"
          cache: true

      - name: Run tests
        if: steps.changes.outputs.code == 'true'
        run: go test -v -race ./pkg/...

  semantic-release:
    name: Semantic Release
    runs-on: ubuntu-latest
    needs: test
    outputs:
      version: ${{ steps.semantic.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Run go-semantic-release
        id: semantic
        uses: go-semantic-release/action@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-descriptions:
    name: Generate LLM Descriptions
    runs-on: ubuntu-latest
    needs: semantic-release
    if: needs.semantic-release.outputs.version != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache: true

      - name: Build CLI for spec hash
        run: make build

      - name: Compute spec hash
        id: spec-hash
        run: |
          SPEC_HASH=$(./f5xcctl --spec | sha256sum | cut -d' ' -f1)
          echo "hash=$SPEC_HASH" >> $GITHUB_OUTPUT
          echo "Spec hash: $SPEC_HASH"

      - name: Check LLM descriptions cache
        id: cache-descriptions
        uses: actions/cache@v4
        with:
          path: pkg/types/descriptions_generated.json
          key: llm-descriptions-${{ steps.spec-hash.outputs.hash }}

      - name: Install Ollama
        if: steps.cache-descriptions.outputs.cache-hit != 'true'
        run: |
          curl -fsSL https://ollama.com/install.sh | sh

      - name: Start Ollama Server
        if: steps.cache-descriptions.outputs.cache-hit != 'true'
        run: |
          # Kill any existing Ollama processes to avoid "address already in use" error
          pkill ollama || true
          sleep 2

          # Start Ollama server in background
          nohup ollama serve > /tmp/ollama.log 2>&1 &
          OLLAMA_PID=$!
          echo "OLLAMA_PID=$OLLAMA_PID" >> $GITHUB_ENV

          # Wait for Ollama to be ready with better error handling
          echo "Waiting for Ollama server to start..."
          for i in {1..60}; do
            if curl -s http://localhost:11434/api/tags > /dev/null 2>&1; then
              echo "✅ Ollama server is ready (attempt $i)"
              exit 0
            fi
            if [ $((i % 10)) -eq 0 ]; then
              echo "Still waiting for Ollama server... ($i/60)"
              echo "--- Ollama log tail ---"
              tail -5 /tmp/ollama.log 2>/dev/null || true
              echo "---"
            fi
            sleep 2
          done

          echo "::error::Ollama server failed to start within 120 seconds"
          echo "--- Full Ollama log ---"
          cat /tmp/ollama.log
          exit 1

      - name: Pull Model
        if: steps.cache-descriptions.outputs.cache-hit != 'true'
        run: |
          echo "Pulling model mistral:7b-instruct..."
          if ! ollama pull "mistral:7b-instruct"; then
            echo "::error::Failed to pull Ollama model mistral:7b-instruct"
            exit 1
          fi
          echo "✅ Model pulled successfully"

      - name: Generate LLM Descriptions
        if: steps.cache-descriptions.outputs.cache-hit != 'true'
        run: |
          echo "Cache miss - generating LLM descriptions..."
          # Run with CI mode for GitHub Actions annotations
          # Use 2 workers to avoid overwhelming Ollama on CI runners
          go run scripts/generate-llm-descriptions.go \
            -ci \
            -v \
            -timeout 180s \
            -max-retries 3 \
            -fail-threshold 0.2 \
            -workers 2 \
            -model "mistral:7b-instruct" \
            -specs docs/specifications/api \
            -output pkg/types/descriptions_generated.json

          # Regenerate schemas with new descriptions
          go run scripts/generate-schemas.go -v -update-resources -use-llm-descriptions

      - name: Use cached descriptions
        if: steps.cache-descriptions.outputs.cache-hit == 'true'
        run: |
          echo "Cache hit - using cached LLM descriptions"
          echo "Regenerating schemas with cached descriptions..."
          go run scripts/generate-schemas.go -v -update-resources -use-llm-descriptions

      - name: Verify Build
        run: |
          make build
          make test-unit

      - name: Commit changes if any
        run: |
          if git diff --quiet pkg/types/; then
            echo "✅ No changes to descriptions - schemas are up to date"
          else
            echo "Committing updated descriptions..."
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add pkg/types/descriptions_generated.json pkg/types/schemas_generated.go pkg/types/resources_generated.go

            # Commit the changes
            if ! git commit -m "chore: regenerate resource descriptions with LLM [skip ci]"; then
              echo "::warning::No changes to commit (files may be unchanged)"
              exit 0
            fi

            # Push with retry logic for branch protection race conditions
            MAX_RETRIES=3
            for i in $(seq 1 $MAX_RETRIES); do
              echo "Push attempt $i/$MAX_RETRIES..."
              if git push; then
                echo "✅ Changes pushed successfully"
                exit 0
              fi

              if [ $i -lt $MAX_RETRIES ]; then
                echo "::warning::Push failed, pulling latest and retrying..."
                git pull --rebase
                sleep 2
              fi
            done

            # If all retries fail, warn but don't fail the job
            # The descriptions are still generated and cached
            echo "::warning::Could not push description updates after $MAX_RETRIES attempts"
            echo "::warning::This may happen due to branch protection rules or concurrent updates"
            echo "::warning::The descriptions are still cached and will be used in future builds"
          fi

  goreleaser:
    name: GoReleaser
    runs-on: ubuntu-latest
    needs: [semantic-release, generate-descriptions]
    if: needs.semantic-release.outputs.version != ''
    outputs:
      version: ${{ needs.semantic-release.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: "1.25"
          cache: false

      - name: Install GoReleaser with retry
        shell: bash
        run: |
          GORELEASER_VERSION="2.13.1"
          max_retries=5
          base_delay=15

          for attempt in $(seq 1 $max_retries); do
            echo "Attempt $attempt of $max_retries to install GoReleaser v${GORELEASER_VERSION}..."

            # Download goreleaser tarball from GitHub releases
            url="https://github.com/goreleaser/goreleaser/releases/download/v${GORELEASER_VERSION}/goreleaser_Linux_x86_64.tar.gz"
            if curl -sSL --connect-timeout 30 --max-time 180 -o /tmp/goreleaser.tar.gz "$url" && \
               tar -xzf /tmp/goreleaser.tar.gz -C /tmp goreleaser && \
               sudo mv /tmp/goreleaser /usr/local/bin/goreleaser && \
               chmod +x /usr/local/bin/goreleaser; then
              echo "GoReleaser installed successfully"
              goreleaser --version
              rm -f /tmp/goreleaser.tar.gz
              exit 0
            fi

            if [ $attempt -lt $max_retries ]; then
              delay=$((base_delay * attempt))
              echo "::warning::Failed to install GoReleaser on attempt $attempt, retrying in ${delay}s..."
              rm -f /tmp/goreleaser.tar.gz /tmp/goreleaser
              sleep $delay
            fi
          done

          echo "::error::Failed to install GoReleaser after $max_retries attempts"
          exit 1

      - name: Run GoReleaser
        shell: bash
        run: goreleaser release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HOMEBREW_TAP_GITHUB_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}

  sign-macos:
    name: Sign macOS Binaries
    runs-on: macos-latest
    needs: goreleaser
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Import Code Signing Certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Store for later steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          # Decode certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          echo "Certificate decoded, checking..."

          # Verify p12 is valid
          openssl pkcs12 -info -in $RUNNER_TEMP/certificate.p12 -noout -passin pass:"$APPLE_CERTIFICATE_PASSWORD" || {
            echo "ERROR: Invalid p12 file or wrong password"
            exit 1
          }

          # Create and configure keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security default-keychain -s $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate with proper options
          echo "Importing certificate..."
          security import $RUNNER_TEMP/certificate.p12 \
            -k $KEYCHAIN_PATH \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security

          # Allow codesign to access the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Add to search list
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Verify import worked
          echo "Verifying certificate import..."
          security find-identity -v -p codesigning $KEYCHAIN_PATH

          # Clean up certificate file
          rm $RUNNER_TEMP/certificate.p12

      - name: Download and Sign macOS Binaries
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ needs.goreleaser.outputs.version }}"
          echo "Signing version: $VERSION"

          # Unlock keychain for this step
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Find the Developer ID Application certificate from our keychain
          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          SIGNING_IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          if [ -z "$SIGNING_IDENTITY" ]; then
            echo "ERROR: No Developer ID signing identity found"
            exit 1
          fi
          echo "Using signing identity: $SIGNING_IDENTITY"

          # Process each macOS architecture
          for ARCH in amd64 arm64; do
            ASSET_NAME="f5xcctl_${VERSION}_darwin_${ARCH}.tar.gz"
            echo "Processing $ASSET_NAME..."

            # Download release asset
            gh release download "v${VERSION}" -p "$ASSET_NAME" -D $RUNNER_TEMP

            # Extract
            mkdir -p $RUNNER_TEMP/sign_${ARCH}
            tar -xzf $RUNNER_TEMP/$ASSET_NAME -C $RUNNER_TEMP/sign_${ARCH}

            # Sign the binary
            BINARY_PATH="$RUNNER_TEMP/sign_${ARCH}/f5xcctl"
            echo "Signing $BINARY_PATH..."

            codesign --force --options runtime --sign "$SIGNING_IDENTITY" --timestamp "$BINARY_PATH"

            # Verify signature
            codesign --verify --verbose "$BINARY_PATH"

            # Create ZIP for notarization
            ZIP_PATH="$RUNNER_TEMP/f5xcctl_${ARCH}.zip"
            ditto -c -k --keepParent "$BINARY_PATH" "$ZIP_PATH"

            # Submit for notarization and wait for completion
            echo "Submitting for notarization..."
            xcrun notarytool submit "$ZIP_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait

            # Note: Stapling is NOT possible for standalone binaries or ZIP files
            # Apple's stapler only works with .app bundles, .dmg, and .pkg files
            # For bare binaries, Gatekeeper verifies the notarization ticket online
            # when the user first runs the binary - no stapling needed
            echo "Notarization complete for $ARCH (stapling skipped - not supported for bare binaries)"

            # Verify the signed binary with spctl
            echo "Verifying signed binary with spctl..."
            spctl -a -vvv -t execute "$BINARY_PATH" || {
              echo "WARNING: spctl verification may fail in CI (no GUI), continuing..."
            }
            echo "Binary ready for $ARCH"

            # Repackage as tar.gz (preserving all original files including completions)
            cd $RUNNER_TEMP/sign_${ARCH}
            # Use * to get all files without ./ prefix, preserving original archive structure
            tar -czf $RUNNER_TEMP/${ASSET_NAME} *
            cd -

            # Upload signed binary to release (replace unsigned)
            echo "Uploading signed $ASSET_NAME..."
            gh release upload "v${VERSION}" $RUNNER_TEMP/$ASSET_NAME --clobber
          done

          echo "macOS binaries signed and uploaded successfully!"

      - name: Regenerate checksums.txt with signed binary hashes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.goreleaser.outputs.version }}"
          echo "Regenerating checksums.txt for version $VERSION..."

          # Create working directory
          mkdir -p $RUNNER_TEMP/checksums
          cd $RUNNER_TEMP/checksums

          # Download all release assets
          echo "Downloading all release assets..."
          GH_TOKEN="$GITHUB_TOKEN" gh release download "v${VERSION}" --repo "${{ github.repository }}"

          # Generate new checksums.txt
          echo "Computing SHA256 checksums..."
          shasum -a 256 f5xcctl_${VERSION}_*.tar.gz f5xcctl_${VERSION}_*.zip 2>/dev/null | tee checksums.txt

          # Upload new checksums.txt to replace the old one
          echo "Uploading updated checksums.txt..."
          GH_TOKEN="$GITHUB_TOKEN" gh release upload "v${VERSION}" checksums.txt --clobber --repo "${{ github.repository }}"

          echo "checksums.txt regenerated successfully!"

      - name: Update Homebrew cask with signed binary hashes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          VERSION="${{ needs.goreleaser.outputs.version }}"

          echo "Computing SHA256 hashes for all release assets..."

          # Download all release tarballs and compute hashes
          mkdir -p $RUNNER_TEMP/hash_check
          cd $RUNNER_TEMP/hash_check

          # Download and compute hash for each platform (using GITHUB_TOKEN for f5xcctl repo)
          for PLATFORM in darwin_amd64 darwin_arm64 linux_amd64 linux_arm64; do
            ASSET="f5xcctl_${VERSION}_${PLATFORM}.tar.gz"
            echo "Downloading $ASSET..."
            GH_TOKEN="$GITHUB_TOKEN" gh release download "v${VERSION}" --pattern "$ASSET" --repo "${{ github.repository }}"
            HASH=$(shasum -a 256 "$ASSET" | cut -d' ' -f1)
            # Export hash as environment variable for later use
            export "HASH_${PLATFORM}=${HASH}"
            echo "$PLATFORM: $HASH"
          done

          # Clone homebrew-tap and update cask (using HOMEBREW_TAP_TOKEN for push access)
          cd $RUNNER_TEMP
          git clone https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/robinmordasiewicz/homebrew-tap.git
          cd homebrew-tap

          # Update the cask file with correct hashes
          cat > Casks/f5xcctl.rb << CASKEOF
          # This file was generated by GoReleaser. DO NOT EDIT.
          cask "f5xcctl" do
            name "f5xcctl"
            desc "Command-line interface for F5 Distributed Cloud"
            homepage "https://robinmordasiewicz.github.io/f5xcctl"
            version "${VERSION}"

            livecheck do
              skip "Auto-generated on release."
            end

            binary "f5xcctl"
            bash_completion "completions/f5xcctl.bash"
            zsh_completion "completions/f5xcctl.zsh"
            fish_completion "completions/f5xcctl.fish"

            on_macos do
              on_intel do
                url "https://github.com/robinmordasiewicz/f5xcctl/releases/download/v#{version}/f5xcctl_#{version}_darwin_amd64.tar.gz"
                sha256 "${HASH_darwin_amd64}"
              end
              on_arm do
                url "https://github.com/robinmordasiewicz/f5xcctl/releases/download/v#{version}/f5xcctl_#{version}_darwin_arm64.tar.gz"
                sha256 "${HASH_darwin_arm64}"
              end
            end

            on_linux do
              on_intel do
                url "https://github.com/robinmordasiewicz/f5xcctl/releases/download/v#{version}/f5xcctl_#{version}_linux_amd64.tar.gz"
                sha256 "${HASH_linux_amd64}"
              end
              on_arm do
                url "https://github.com/robinmordasiewicz/f5xcctl/releases/download/v#{version}/f5xcctl_#{version}_linux_arm64.tar.gz"
                sha256 "${HASH_linux_arm64}"
              end
            end

            caveats <<~EOS
              Shell completions have been installed for bash, zsh, and fish.

              For setup instructions, see:
                https://robinmordasiewicz.github.io/f5xcctl/install/homebrew/#shell-completions

              Quick start:
                Zsh: Usually works automatically. Restart your terminal.
                Bash: Run 'brew install bash-completion@2' first.
                Fish: Works automatically.

              Test with: f5xcctl [TAB]
            EOS
          end
          CASKEOF

          # Remove leading whitespace from heredoc
          sed -i '' 's/^          //' Casks/f5xcctl.rb

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Casks/f5xcctl.rb
          git commit -m "fix: update SHA256 hashes for signed macOS binaries v${VERSION}"
          git push
